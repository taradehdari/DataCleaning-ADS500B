---
title: "bank_marketing"
output: html_document
date: "2023-04-03"
---

```{r setup, include=FALSE}
library (ggplot2)
library(dplyr)
library(tidyverse)
library(scales)
knitr::opts_chunk$set(echo = TRUE)
```

The dataset was collected from the UCI Machine Learning Repository covering the period from May 2008 to November 2010. The dataset pertains to the direct marketing campaigns conducted by a Portuguese banking institution. These campaigns involved making phone calls to potential clients to promote a bank term deposit product. In some cases, multiple contacts with the same client were necessary to determine if they are interested in subscribing to the deposit product or not.

The bank_marketing.csv file is imported using the read.csv() function where the fields are separated by the semicolon (;). This function reads the data and stores it in a clientdata data frame. The dataset has 45211 rows and 17 columns. 

The dataset contains a mix of numerical and categorical variables. The “age”, “balance”, “day”, “duration”, “campaign”, “pdays”, and “previous” variables are numerical variables. On the other hand, the variables “job”, “marital”, “education”, “contact”, “month”, and “poutcome” are categorical. Moreover, the dataset contains binary variables which include “default”, “housing”, “loan”, and “deposit” fields. 

```{r}
clientdata <- read.csv("bank_marketing.csv",header=T,sep=";")
#Returns no of rows and columns
dim(clientdata)
#Returns the data type of the columns
str(clientdata)
View(clientdata)
```

##Handling Missing values

The dataset contains missing values in the Age (1339), default (1306), and contact (1383) fields. 

Looking at the descriptive statistics, we observe that the maximum values for numerical columns are too skewed, so the mean will not be a meaningful replacement for missing values as the data is not normally distributed. Hence replacing the missing values using the median.

Default and contact columns are categorical and not numerical. Replacing the missing value with the mode would not be appropriate in this case. Hence, we can remove the records with the missing values in both columns.

```{r}
colSums(is.na(clientdata) | clientdata == "")
#Filtering rows which has non missing values in default and contact columns
clientdata <- clientdata %>% filter(default != "" & contact != "")
#Replace missing values in the "age" column with the median age of all non missing values in the same column
clientdata <- clientdata %>% mutate(across(age, ~replace_na(., median(., na.rm=TRUE))))
colSums(is.na(clientdata) | clientdata == "")
summary(clientdata)
```
##Identifying and Treating Outliers

Box plots were created to identify the outliers for the numerical variables- Age, Balance, Day, Duration, Campaign, Pdays, and Previous. In general, removing outliers from a large dataset is a common practice in data preprocessing and analysis, especially when the outliers are believed to be due to errors or measurement issues. 

Age, Balance, Duration, Campaign, and Pdays – Outliers in these variables are not removed because removing them may provide a loss of information and distortion of the distribution of the data.

Day – No outliers present.

Previous – Holds the number of contacts performed before this campaign for the client. The value ranges between 0 and 58, barring one value to be 275. This value is assumed to be an outlier and is removed.


```{r}
#identifying outliers
ggplot(data = clientdata, aes(x = "", y = age)) + geom_boxplot() + 
  labs(title = "Boxplot of Age in Bank Marketing Dataset", x = "Age", y = "Values")
ggplot(data = clientdata, aes(x = "", y = balance)) + geom_boxplot() + 
  labs(title = "Boxplot of Balance in Bank Marketing Dataset", x = "Balance", y = "Avg yearly balance in Euros")
ggplot(data = clientdata, aes(x = "", y = day)) + geom_boxplot() + 
  labs(title = "Boxplot of Day in Bank Marketing Dataset", x = "Day", y = "Last contact day")
ggplot(data = clientdata, aes(x = "", y = duration)) + geom_boxplot() + 
  labs(title = "Boxplot of Duration in Bank Marketing Dataset", x = "Duration", y = "Duration in seconds")
ggplot(data = clientdata, aes(x = "", y = campaign)) + geom_boxplot() + 
  labs(title = "Boxplot of Campaign in Bank Marketing Dataset", x = "Campaign", y = "No of contacts during this campaign")
ggplot(data = clientdata, aes(x = "", y = pdays)) + geom_boxplot() + 
  labs(title = "Boxplot of Pdays in Bank Marketing Dataset", x = "Pdays", y = "No of days passed since last contact")
ggplot(data = clientdata, aes(x = "", y = previous)) + geom_boxplot() + 
  labs(title = "Boxplot of Previous in Bank Marketing Dataset", x = "previous", y = "No of contacts before this campaign")
```

```{r}
#Treating Outliers
clientdata <- clientdata %>% filter(previous != max(previous))
#Checking the box plot of Previous variable after removing one outlier
ggplot(data = clientdata, aes(x = "", y = previous)) + geom_boxplot() +
  labs(title = "Boxplot of Previous variable in Bank Marketing Dataset", x = "previous", y = "No of contacts")
summary(clientdata$previous)
```

## Data Aggregation

```{r}
#Aggregating the data by job type
clientdata %>% group_by(job) %>% summarize(total_deposits = sum(deposit == 'yes')) %>% arrange(desc(total_deposits))
```
The above table shows the number of term deposits subscribed by the clients based on their job type. Based on the data provided, it appears that clients in management roles have subscribed to the highest number of term deposits, with a total of 1232 deposits, followed by technicians with 795 deposits and blue-collar workers with 670 deposits.

Clients in the services, student, unemployed, self-employed, and entrepreneur categories have subscribed to fewer term deposits, with the numbers ranging from 115 to 344.

The is the total number of deposits based on job type not taking into account that there might be more management in the dataset. Later in the file we can see the normalized data and see that although there are less deposits in students the ratio of students who had a deposit and the amount of students in the data set are higher tha the other job categories. 

```{r}
#Aggregating the data by month
clientdata %>% group_by(month) %>% summarize(total_deposits = sum(deposit == 'yes')) %>% arrange(desc(total_deposits))
clientdata %>% group_by(month) %>% summarize(total_contacts = sum(campaign)) %>% arrange(desc(total_contacts))
```

The output shows the total number of deposits subscribed for each month in the marketing campaign. Looking at the data, we can see that May had the highest number of deposits, with a total of 880. This suggests that the marketing campaign was particularly successful in May or that customers tend to have more income or savings during this time of year.  

The second-highest number of deposits were subscribed in August, with a total of 658 deposits followed by July, with a total of 590 deposits. This indicates that the campaign was also successful in these months.


## Data Normalization
This was an intial attempet at Normalization but upon visualizations we figured another way to normalize data that would help our vizualisations to find a perfect model. 

```{r}

#The scale of age and duration is much smaller than the scale of balance. In this case, normalizing these variables to a common range allows comparing variables that are measured on different scales or units.
#Min-Max Normalization using xRescale function to scale the age, balance and duration
#clientdata <- clientdata %>% mutate(age = round(rescale(age, to=c(0,1)),3),
                      #balance = round(rescale(balance, to=c(0,1)),3),
                      #duration = round(rescale(duration, to=c(0,1)),3))
#View(clientdata)
#Summary(clientdata)
```

In this code we are looking at the correlation between the numerical values. The first line of code creates a variable called cols that includes all of the numerical columns in the data set client data. The next line of code creates the correlation matrix with the numeric columns and the third line of code prints out the correlation matrix. Through the output we can see that none of the numeric values show any high correlation. 

```{r}
#2c diagnose correlations between variables and determine indpendent and dependent variables
#correlation matrix
cols <- c("age", "balance", "duration","campaign", "pdays", "previous", "day")
corr_matrix <- cor(clientdata[, cols])
options(scipen = 999) # disable scientific notation
print(corr_matrix, digits = 6) # specify the number of decimal places

```
For numerical values the mean, median, and mode were calculated to look at the measures of centrality. The measures of centrality provides information about the skewness of the dataset. EXPLAIN SKEWNESS
```{r}
#2b: provides measures of centrality and distribution with visualizations

#numerical measures of centrality --> mean, median, mode
#measures of centrality of age
mean_age <- round(mean(clientdata$age),2)
median_age <- round(median(clientdata$age),2)
mode_age <- clientdata %>% 
  count(age) %>% 
  filter(n == max(n)) %>% 
  pull(age)

print(paste("The mean of age is", mean_age))
print(paste("The median of age is", median_age))
print(paste("The mode of age is", mode_age))

#measures of centrality of balance
mean_balance <- round(mean(clientdata$balance),2)
median_balance <- round(median(clientdata$balance),2)
mode_balance <- clientdata %>% 
  count(balance) %>% 
  filter(n == max(n)) %>% 
  pull(balance)

print(paste("The mean of balance is", mean_balance))
print(paste("The median of balance is", median_balance))
print(paste("The mode of balance is", mode_balance))

#measures of centrality of day
mean_day <- round(mean(clientdata$day),2)
median_day <- round(median(clientdata$day),2)
mode_day <- clientdata %>% 
  count(day) %>% 
  filter(n == max(n)) %>% 
  pull(day)

print(paste("The mean of day is", mean_day))
print(paste("The median of day is", median_day))
print(paste("The mode of day is", mode_day))

#measures of centrality of duration
mean_duration <- round(mean(clientdata$duration),2)
median_duration <- round(median(clientdata$duration),2)
mode_duration <- clientdata %>% 
  count(duration) %>% 
  filter(n == max(n)) %>% 
  pull(duration)

print(paste("The mean of duration is", mean_duration))
print(paste("The median of duration is", median_duration))
print(paste("The mode of duration is", mode_duration))

#measures of centrality of campaign
mean_campaign <- round(mean(clientdata$campaign),2)
median_campaign <- round(median(clientdata$campaign),2)
mode_campaign <- clientdata %>% 
  count(campaign) %>% 
  filter(n == max(n)) %>% 
  pull(campaign)

print(paste("The mean of campaign is", mean_campaign))
print(paste("The median of campaign is", median_campaign))
print(paste("The mode of campaign is", mode_campaign))

#measures of centrality of pdays
mean_pdays <- round(mean(clientdata$pdays),2)
median_pdays <- round(median(clientdata$pdays),2)
mode_pdays <- clientdata %>% 
  count(pdays) %>% 
  filter(n == max(n)) %>% 
  pull(pdays)

print(paste("The mean of pdays is", mean_pdays))
print(paste("The median of pdays is", median_pdays))
print(paste("The mode of pdays is", mode_pdays))

#measures of centrality of previous
mean_previous <- round(mean(clientdata$previous),2)
median_previous <- round(median(clientdata$previous),2)
mode_previous <- clientdata %>% 
  count(previous) %>% 
  filter(n == max(n)) %>% 
  pull(previous)

print(paste("The mean of previous is", mean_previous))
print(paste("The median of previous is", median_previous))
print(paste("The mode of previous is", mode_previous))
```
For categorical variables mode was calculated to observe the measures of centrality. The mode of each categorical variables shows what is most used in each categorical variable. So there are more blue-collar jobs observed in the data set. There are more married couples in this data set. There are more people who completed secondary education than other education levels. The primary mode of contact is cellular. Majority of people were last contacted in May, and majority of the outcome of the previous marketing campaign is unknown.

```{r}
#categorical measures of centrality --> mode
#mode of job
mode_job <- clientdata %>% 
  count(job) %>% 
  filter(n == max(n)) %>% 
  pull(job)

#mode of marital
mode_marital <- clientdata %>% 
  count(marital) %>% 
  filter(n == max(n)) %>% 
  pull(marital)

#mode of education
mode_education <- clientdata %>% 
  count(education) %>% 
  filter(n == max(n)) %>% 
  pull(education)

#mode of contact
mode_contact <- clientdata %>% 
  count(contact) %>% 
  filter(n == max(n)) %>% 
  pull(contact)

#mode of month
mode_month <- clientdata %>% 
  count(month) %>% 
  filter(n == max(n)) %>% 
  pull(month)

#mode of poutcome
mode_poutcome <- clientdata %>% 
  count(poutcome) %>% 
  filter(n == max(n)) %>% 
  pull(poutcome)

print(paste("The mode of jobs is", mode_job))
print(paste("The mode of marital is", mode_marital))
print(paste("The mode of education is", mode_education))
print(paste("The mode of contact is", mode_contact))
print(paste("The mode of month is", mode_month))
print(paste("The mode of poutcome is", mode_poutcome))
```
For the binary measures of centrality the frequency tables were printed. There are more no in default, loan and deposit than yes, and there are more yes in housing than no. 
```{r}
#binary measures of centrality --> frequency tables 
# Create frequency tables of the binary columns
default_table <- table(clientdata$default)
housing_table <- table(clientdata$housing)
loan_table <- table(clientdata$loan)
deposit_table <- table(clientdata$deposit)

#print frequency tables
print("The frequency table for default is:")
print(default_table)

print("The frequency table for housing is:")
print(housing_table)

print("The frequency table for loan is:")
print(loan_table)

print("The frequency table for deposit is:")
print(deposit_table)


```
Measures of distribution provide information about the spread of the dataset.

```{r}
#getting measures of distribution for numerical variables--> range, variance, standard deviation, interquartile range
#measures of distribution of age
var_age <- round(var(clientdata$age),2)
sd_age <- round(sd(clientdata$age),2)
IQR_age <- round(IQR(clientdata$age),2)
summary(clientdata$age)
q1_age <- summary(clientdata$age)[2]
q3_age <- summary(clientdata$age)[5]
range_age <- summary(clientdata$age)[6] - summary(clientdata$age)[1]

print(paste("The range of age is", range_age))
print(paste("The variance of age is", var_age))
print(paste("The standard deviation of age is", sd_age))
print(paste("The IQR of age is", IQR_age))
print(paste("The first quartile of age is", q1_age))
print(paste("The third quaratile of age is", q3_age))
```

```{r}
#measures of distribution of balance
var_balance <- round(var(clientdata$balance),2)
sd_balance <- round(sd(clientdata$balance),2)
IQR_balance <- round(IQR(clientdata$balance),2)
summary(clientdata$balance)
q1_balance <- summary(clientdata$balance)[2]
q3_balance <- summary(clientdata$balance)[5]
range_balance <- summary(clientdata$balance)[6] - summary(clientdata$balance)[1]

print(paste("The range of balance is", range_balance))
print(paste("The variance of balance is", var_balance))
print(paste("The standard deviation of balance is", sd_balance))
print(paste("The IQR of balance is", IQR_balance))
print(paste("The first quartile of balance is", q1_balance))
print(paste("The third quaratile of balance is", q3_balance))

```
```{r}
#measures of distribution of duration
var_duration <- round(var(clientdata$duration),2)
sd_duration <- round(sd(clientdata$duration),2)
IQR_duration <- round(IQR(clientdata$duration),2)
summary(clientdata$duration)
q1_duration <- summary(clientdata$duration)[2]
q3_duration <- summary(clientdata$duration)[5]
range_duration <- summary(clientdata$duration)[6] - summary(clientdata$duration)[1]

print(paste("The range of duration is", range_duration))
print(paste("The variance of duration is", var_duration))
print(paste("The standard deviation of duration is", sd_duration))
print(paste("The IQR of duration is", IQR_duration))
print(paste("The first quartile of duration is", q1_duration))
print(paste("The third quaratile of duration is", q3_duration))
```
```{r}
#measures of distribution of campaign
var_campaign <- round(var(clientdata$campaign),2)
sd_campaign <- round(sd(clientdata$campaign),2)
IQR_campaign <- round(IQR(clientdata$campaign),2)
summary(clientdata$campaign)
q1_campaign <- summary(clientdata$campaign)[2]
q3_campaign <- summary(clientdata$campaign)[5]
range_campaign <- summary(clientdata$campaign)[6] - summary(clientdata$campaign)[1]

print(paste("The range of campaign is", range_campaign))
print(paste("The variance of campaign is", var_campaign))
print(paste("The standard deviation of campaign is", sd_campaign))
print(paste("The IQR of campaign is", IQR_campaign))
print(paste("The first quartile of campaign is", q1_campaign))
print(paste("The third quaratile of campaign is", q3_campaign))
```

```{r}
#previous", "day"
#measures of distribution of pdays
var_pdays <- round(var(clientdata$pdays),2)
sd_pdays <- round(sd(clientdata$pdays),2)
IQR_pdays <- round(IQR(clientdata$pdays),2)
summary(clientdata$pdays)
q1_pdays <- summary(clientdata$pdays)[2]
q3_pdays <- summary(clientdata$pdays)[5]
range_pdays <- summary(clientdata$pdays)[6] - summary(clientdata$pdays)[1]

print(paste("The range of pdays is", range_pdays))
print(paste("The variance of pdays is", var_pdays))
print(paste("The standard deviation of pdays is", sd_pdays))
print(paste("The IQR of pdays is", IQR_pdays))
print(paste("The first quartile of pdays is", q1_pdays))
print(paste("The third quaratile of pdays is", q3_pdays))
```
```{r}
#measures of distribution of previous
var_previous <- round(var(clientdata$previous),2)
sd_previous <- round(sd(clientdata$previous),2)
IQR_previous <- round(IQR(clientdata$previous),2)
summary(clientdata$previous)
q1_previous <- summary(clientdata$previous)[2]
q3_previous <- summary(clientdata$previous)[5]
range_previous <- summary(clientdata$previous)[6] - summary(clientdata$previous)[1]

print(paste("The range of previous is", range_previous))
print(paste("The variance of previous is", var_previous))
print(paste("The standard deviation of previous is", sd_previous))
print(paste("The IQR of previous is", IQR_previous))
print(paste("The first quartile of previous is", q1_previous))
print(paste("The third quaratile of previous is", q3_previous))
```
```{r}
#measures of distribution of day
var_day <- round(var(clientdata$day),2)
sd_day <- round(sd(clientdata$day),2)
IQR_day <- round(IQR(clientdata$day),2)
summary(clientdata$day)
q1_day <- summary(clientdata$day)[2]
q3_day <- summary(clientdata$day)[5]
range_day <- summary(clientdata$day)[6] - summary(clientdata$day)[1]

print(paste("The range of day is", range_day))
print(paste("The variance of day is", var_day))
print(paste("The standard deviation of day is", sd_day))
print(paste("The IQR of day is", IQR_day))
print(paste("The first quartile of day is", q1_day))
print(paste("The third quaratile of day is", q3_day))
```

```{r}
#measures of distribution for categorical and binary variables --> frequency
categorical_vars <- c("job","marital","education","contact", "month", "poutcome", "deposit", "housing", "loan", "default")
for (var in categorical_vars){
  freq_table <- table(clientdata[[var]])
  print(paste("Frequency table for", var))
  print(freq_table)
}

```
##Exploratory Visualizations
These groups of code were to look at different types of visualizations with the different data sets. 
 
Previous and pdays had the highest correlation out of all the data sets with a correlation of 0.5441. Duration and pdays had the lowest correlation with a correlation of -0.000885. 

```{r}
#2d: perform exploratory analysis in combination with visualization techniques to discover patterns and feautures of interest 


ggplot(clientdata, aes(x = previous, y = pdays)) +
  geom_point() +
  labs(title = "Scatter plot of previous and pdays", x = "Previous", y = "Pdays")

ggplot(clientdata, aes(x = duration, y = pdays)) +
  geom_point() +
  labs(title = "Scatter plot of duration and pdays", x = "Duration", y = "Pdays")

```

These were histograms used to visualize the distribution of individual variables, just to look at the spread and skewness. 
```{r}
#histogram to visualize the distribution of individual variables

#histogram of duration
hist(clientdata$duration, main = "Histogram of Duration", xlab = "Duration", ylab = "Frequency")

#histogram of pdays
hist(clientdata$pdays, main = "Histogram of Pdays", xlab = "Pdays", ylab = "Frequency")

#histogram of days
hist(clientdata$day, main="Histogram of Days", breaks = 40, xlab= "Days", ylab="Frequency")
```

```{r}
ggplot(clientdata, aes(fill=deposit, y=balance, x=deposit)) + 
    geom_bar(position="dodge", stat="identity") +
    ggtitle("Studying 4 Outcomes of Previous Campaign vs. Deposit Made") +
    facet_wrap(~poutcome) +
    theme(legend.position="none") +
    xlab("Deposit Made") +
    ylab("Balance (€)")
```


##Normalizations and Visualizations
Our dependent variable is deposit and in order to build a final model cluster bar charts were created to visualize what type of clients are more likely to put in deposits. First age and deposit were graphed on a cluster bar chart in order to see which age group had the highest deposits, through initial visualization it was noticed that there were more deposits in the age group that the data set had more of (30-39 year olds), in order to create bar charts that would give an understanding of the relationship between age and deposit the data had to be normalized. From the normalized bar chart it is seen that 80-95 year olds have the highest amount of deposits. To normalize the data the count of each yes or no in each age group was divided by the total number of clients in that age group. This normalized the data so that when the data set had more data for ages 30-39 it wouldn't matter. Through the scatter plot of age and balance we can see that from ages 50-59 people tend to have a higher balance but less deposits (which we can see in the barchart).  
```{r}
# Creating age groups
clientdata$age_group <- cut(clientdata$age, breaks = c(15, 29, 39, 49, 59, 69, 79, 95), labels = c("18-29", "30-39", "40-49", "50-59", "60-69", "70-79", "80-95"))

# Converting age to a factor
clientdata$age_group <- factor(clientdata$age_group, levels = c("18-29", "30-39", "40-49", "50-59", "60-69", "70-79", "80-95"))

# Save the modified data back to same file
write.csv(clientdata, "clientdata.csv", row.names = FALSE)

# Group data by age group and deposit, and count number of observations
df <- clientdata %>%
  group_by(age_group, deposit) %>%
  summarize(count = n()) %>%
  ungroup()

# Create clustered bar chart deposit vs, age 
ggplot(df, aes(x = age_group, y = count, fill = deposit)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Deposits by Age Group",
       x = "Age Group",
       y = "Count of Deposits",
       fill = "Deposit") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

#bar chart of age group to see which age group is most in the dataset
# Group data by age group and calculate the count
agecount <- clientdata %>%
  group_by(age_group) %>%
  summarize(count = n()) %>%
  ungroup()

# Create bar chart of age groups
ggplot(agecount, aes(x = age_group, y = count)) +
  geom_bar(stat = "identity") +
  labs(title = "Clients by Age Group",
       x = "Age Group",
       y = "Count of Clients") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

#30-49 age is highest which is why there are more deposits in that age group to fix this we are going to normalize the counts by the total number of clients in each age group,this way the resulting count will take into account that there are different number of clients in each age group.
# group data by age group and calculate the count (which we have above)
#view(agecount)
# group data by age and deposit and calculate the count
age_depo_count <- clientdata %>%
  group_by(age_group, deposit) %>%
  summarize(count = n()) %>%
  ungroup()

# join two datasets by age group and deposit
age_depo_count_norm <- left_join(age_depo_count, agecount, by = "age_group")
#view(age_depo_count_norm)

# calculate the normalized count of deposits
age_depo_count_norm$count_norm <- age_depo_count_norm$count.x / age_depo_count_norm$count.y

# clustered bar chart deposit vs, age
ggplot(age_depo_count_norm, aes(x = age_group, y = count_norm, fill = deposit)) + 
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Deposits by Age Group",
       x = "Age Group",
       y = "Normalized Count of Deposits",
       fill = "Deposit") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))


ggplot(clientdata, aes(x = age_group, y = balance)) +
  geom_point() +
  labs(title = "Scatter plot of Age and Balance", x = "Age", y = "Balance")
#deposit y dependent variable

```

Using the job column in the data set, this code chunk is normalizing the number of deposits for each job title and graphing them in a clustered barchart to see what job has the majority of deposits. From the barchart students seem to deposit more than other job types. 
```{r}

# Group data by  job and deposit, and count number of observations
jobcount <- clientdata %>%
  group_by(job) %>%
  summarize(count1 = n()) %>%
  ungroup()
#view(jobcount)

# group data by job and deposit and calculate the count
job_depo_count <- clientdata %>%
  group_by(job, deposit) %>%
  summarize(count = n()) %>%
  ungroup()

#view(job_depo_count)

# join two datasets by job and deposit
job_depo_count_norm <- left_join(job_depo_count, jobcount, by = c("job"))
#view(job_depo_count_norm)

# calculate the normalized count of deposits
job_depo_count_norm$count_norm <- job_depo_count_norm$count / job_depo_count_norm$count1

# clustered bar chart deposit vs, age
ggplot(job_depo_count_norm, aes(x = job, y = count_norm, fill = deposit)) + 
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Deposits by Job",
       x = "Job",
       y = "Normalized Count of Deposits",
       fill = "Deposit") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

```
Using the Marital column in the data set, this code chunk is normalizing the number of deposits for each marital status and graphing them in a clustered barchart to see what marital status has the majority of deposits. From the barchart it seems that people who are single seem to deposit more than other job types. 

```{r}
# Group data by marital and deposit, and count number of observations
maritalcount <- clientdata %>%
  group_by(marital) %>%
  summarize(count1 = n()) %>%
  ungroup()
#view(maritalcount)

# group data by job and deposit and calculate the count
marital_depo_count <- clientdata %>%
  group_by(marital, deposit) %>%
  summarize(count = n()) %>%
  ungroup()

#view(marital_depo_count)

# join two datasets by job and deposit
marital_depo_count_norm <- left_join(marital_depo_count, maritalcount, by = c("marital"))
#view(marital_depo_count_norm)

# calculate the normalized count of deposits
marital_depo_count_norm$count_norm <- marital_depo_count_norm$count / marital_depo_count_norm$count1

# clustered bar chart deposit vs, age
ggplot(marital_depo_count_norm, aes(x = marital, y = count_norm, fill = deposit)) + 
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Deposits by Marital Status",
       x = "Marital",
       y = "Normalized Count of Deposits",
       fill = "Deposit") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

```

## Final Visualization and Model
```{r}

```






